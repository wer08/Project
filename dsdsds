Help on package sqlalchemy:

NNAAMMEE
    sqlalchemy

DDEESSCCRRIIPPTTIIOONN
    # sqlalchemy/__init__.py
    # Copyright (C) 2005-2022 the SQLAlchemy authors and contributors
    # <see AUTHORS file>
    #
    # This module is part of SQLAlchemy and is released under
    # the MIT License: https://www.opensource.org/licenses/mit-license.php

PPAACCKKAAGGEE  CCOONNTTEENNTTSS
    cimmutabledict
    connectors (package)
    cprocessors
    cresultproxy
    databases (package)
    dialects (package)
    engine (package)
    event (package)
    events
    exc
    ext (package)
    future (package)
    inspection
    log
    orm (package)
    pool (package)
    processors
    schema
    sql (package)
    testing (package)
    types
    util (package)

SSUUBBMMOODDUULLEESS
    _util

CCLLAASSSSEESS
    sqlalchemy.sql.base.DialectKWArgs(builtins.object)
        sqlalchemy.sql.schema.Column(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem, sqlalchemy.sql.elements.ColumnClause)
        sqlalchemy.sql.schema.Constraint(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.ForeignKey(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.Index(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.ColumnCollectionMixin, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.Table(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem, sqlalchemy.sql.selectable.TableClause)
    sqlalchemy.sql.base.SchemaEventTarget(builtins.object)
        sqlalchemy.sql.schema.FetchedValue
            sqlalchemy.sql.schema.Computed(sqlalchemy.sql.schema.FetchedValue, sqlalchemy.sql.schema.SchemaItem)
            sqlalchemy.sql.schema.DefaultClause
            sqlalchemy.sql.schema.Identity(sqlalchemy.sql.schema.IdentityOptions, sqlalchemy.sql.schema.FetchedValue, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.sqltypes.ARRAY(sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.sqltypes.Indexable, sqlalchemy.sql.sqltypes.Concatenable, sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.type_api.TypeDecorator(sqlalchemy.sql.type_api.ExternalType, sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.Interval(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes._AbstractInterval, sqlalchemy.sql.type_api.TypeDecorator)
            sqlalchemy.sql.sqltypes.PickleType
    sqlalchemy.sql.ddl.DDLElement(sqlalchemy.sql.roles.DDLRole, sqlalchemy.sql.base.Executable, sqlalchemy.sql.ddl._DDLCompiles)
        sqlalchemy.sql.ddl.DDL
    sqlalchemy.sql.elements.ColumnClause(sqlalchemy.sql.roles.DDLReferredColumnRole, sqlalchemy.sql.roles.LabeledColumnExprRole, sqlalchemy.sql.roles.StrAsPlainColumnRole, sqlalchemy.sql.base.Immutable, sqlalchemy.sql.elements.NamedColumn)
        sqlalchemy.sql.schema.Column(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem, sqlalchemy.sql.elements.ColumnClause)
    sqlalchemy.sql.schema.ColumnCollectionConstraint(sqlalchemy.sql.schema.ColumnCollectionMixin, sqlalchemy.sql.schema.Constraint)
        sqlalchemy.sql.schema.CheckConstraint
        sqlalchemy.sql.schema.ForeignKeyConstraint
        sqlalchemy.sql.schema.PrimaryKeyConstraint
        sqlalchemy.sql.schema.UniqueConstraint
    sqlalchemy.sql.schema.ColumnCollectionMixin(builtins.object)
        sqlalchemy.sql.schema.Index(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.ColumnCollectionMixin, sqlalchemy.sql.schema.SchemaItem)
    sqlalchemy.sql.schema.DefaultGenerator(sqlalchemy.sql.base.Executable, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.ColumnDefault
        sqlalchemy.sql.schema.Sequence(sqlalchemy.sql.schema.IdentityOptions, sqlalchemy.sql.schema.DefaultGenerator)
    sqlalchemy.sql.schema.IdentityOptions(builtins.object)
        sqlalchemy.sql.schema.Identity(sqlalchemy.sql.schema.IdentityOptions, sqlalchemy.sql.schema.FetchedValue, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.Sequence(sqlalchemy.sql.schema.IdentityOptions, sqlalchemy.sql.schema.DefaultGenerator)
    sqlalchemy.sql.schema.SchemaItem(sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.visitors.Traversible)
        sqlalchemy.sql.schema.Column(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem, sqlalchemy.sql.elements.ColumnClause)
        sqlalchemy.sql.schema.Constraint(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.ForeignKey(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.Index(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.ColumnCollectionMixin, sqlalchemy.sql.schema.SchemaItem)
        sqlalchemy.sql.schema.MetaData
            sqlalchemy.sql.schema.ThreadLocalMetaData
        sqlalchemy.sql.schema.Table(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem, sqlalchemy.sql.selectable.TableClause)
    sqlalchemy.sql.selectable.TableClause(sqlalchemy.sql.roles.DMLTableRole, sqlalchemy.sql.base.Immutable, sqlalchemy.sql.selectable.FromClause)
        sqlalchemy.sql.schema.Table(sqlalchemy.sql.base.DialectKWArgs, sqlalchemy.sql.schema.SchemaItem, sqlalchemy.sql.selectable.TableClause)
    sqlalchemy.sql.sqltypes.Concatenable(builtins.object)
        sqlalchemy.sql.sqltypes.ARRAY(sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.sqltypes.Indexable, sqlalchemy.sql.sqltypes.Concatenable, sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.sqltypes.String(sqlalchemy.sql.sqltypes.Concatenable, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.CHAR
            sqlalchemy.sql.sqltypes.Enum(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes.String, sqlalchemy.sql.sqltypes.SchemaType)
            sqlalchemy.sql.sqltypes.Text
                sqlalchemy.sql.sqltypes.CLOB
                sqlalchemy.sql.sqltypes.TEXT
                sqlalchemy.sql.sqltypes.UnicodeText
            sqlalchemy.sql.sqltypes.Unicode
                sqlalchemy.sql.sqltypes.NCHAR
                sqlalchemy.sql.sqltypes.NVARCHAR
            sqlalchemy.sql.sqltypes.VARCHAR
    sqlalchemy.sql.sqltypes.Indexable(builtins.object)
        sqlalchemy.sql.sqltypes.ARRAY(sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.sqltypes.Indexable, sqlalchemy.sql.sqltypes.Concatenable, sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.sqltypes.JSON(sqlalchemy.sql.sqltypes.Indexable, sqlalchemy.sql.type_api.TypeEngine)
    sqlalchemy.sql.sqltypes.SchemaType(sqlalchemy.sql.base.SchemaEventTarget)
        sqlalchemy.sql.sqltypes.Boolean(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.type_api.TypeEngine, sqlalchemy.sql.sqltypes.SchemaType)
            sqlalchemy.sql.sqltypes.BOOLEAN
    sqlalchemy.sql.sqltypes._AbstractInterval(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.sqltypes.Interval(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes._AbstractInterval, sqlalchemy.sql.type_api.TypeDecorator)
    sqlalchemy.sql.sqltypes._Binary(sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.sqltypes.BINARY
        sqlalchemy.sql.sqltypes.LargeBinary
            sqlalchemy.sql.sqltypes.BLOB
        sqlalchemy.sql.sqltypes.VARBINARY
    sqlalchemy.sql.sqltypes._LookupExpressionAdapter(builtins.object)
        sqlalchemy.sql.sqltypes.Date(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.DATE
        sqlalchemy.sql.sqltypes.DateTime(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.DATETIME
            sqlalchemy.sql.sqltypes.TIMESTAMP
        sqlalchemy.sql.sqltypes.Integer(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.BigInteger
                sqlalchemy.sql.sqltypes.BIGINT
            sqlalchemy.sql.sqltypes.INTEGER
            sqlalchemy.sql.sqltypes.SmallInteger
                sqlalchemy.sql.sqltypes.SMALLINT
        sqlalchemy.sql.sqltypes.Numeric(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.DECIMAL
            sqlalchemy.sql.sqltypes.Float
                sqlalchemy.sql.sqltypes.FLOAT
                sqlalchemy.sql.sqltypes.REAL
            sqlalchemy.sql.sqltypes.NUMERIC
        sqlalchemy.sql.sqltypes.Time(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.TIME
    sqlalchemy.sql.type_api.Emulated(builtins.object)
        sqlalchemy.sql.sqltypes.Boolean(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.type_api.TypeEngine, sqlalchemy.sql.sqltypes.SchemaType)
            sqlalchemy.sql.sqltypes.BOOLEAN
        sqlalchemy.sql.sqltypes.Enum(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes.String, sqlalchemy.sql.sqltypes.SchemaType)
        sqlalchemy.sql.sqltypes.Interval(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes._AbstractInterval, sqlalchemy.sql.type_api.TypeDecorator)
    sqlalchemy.sql.type_api.ExternalType(builtins.object)
        sqlalchemy.sql.type_api.TypeDecorator(sqlalchemy.sql.type_api.ExternalType, sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.Interval(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes._AbstractInterval, sqlalchemy.sql.type_api.TypeDecorator)
            sqlalchemy.sql.sqltypes.PickleType
    sqlalchemy.sql.type_api.TypeEngine(sqlalchemy.sql.visitors.Traversible)
        sqlalchemy.sql.sqltypes.ARRAY(sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.sqltypes.Indexable, sqlalchemy.sql.sqltypes.Concatenable, sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.sqltypes.Boolean(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.type_api.TypeEngine, sqlalchemy.sql.sqltypes.SchemaType)
            sqlalchemy.sql.sqltypes.BOOLEAN
        sqlalchemy.sql.sqltypes.Date(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.DATE
        sqlalchemy.sql.sqltypes.DateTime(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.DATETIME
            sqlalchemy.sql.sqltypes.TIMESTAMP
        sqlalchemy.sql.sqltypes.Integer(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.BigInteger
                sqlalchemy.sql.sqltypes.BIGINT
            sqlalchemy.sql.sqltypes.INTEGER
            sqlalchemy.sql.sqltypes.SmallInteger
                sqlalchemy.sql.sqltypes.SMALLINT
        sqlalchemy.sql.sqltypes.JSON(sqlalchemy.sql.sqltypes.Indexable, sqlalchemy.sql.type_api.TypeEngine)
        sqlalchemy.sql.sqltypes.Numeric(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.DECIMAL
            sqlalchemy.sql.sqltypes.Float
                sqlalchemy.sql.sqltypes.FLOAT
                sqlalchemy.sql.sqltypes.REAL
            sqlalchemy.sql.sqltypes.NUMERIC
        sqlalchemy.sql.sqltypes.String(sqlalchemy.sql.sqltypes.Concatenable, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.CHAR
            sqlalchemy.sql.sqltypes.Enum(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes.String, sqlalchemy.sql.sqltypes.SchemaType)
            sqlalchemy.sql.sqltypes.Text
                sqlalchemy.sql.sqltypes.CLOB
                sqlalchemy.sql.sqltypes.TEXT
                sqlalchemy.sql.sqltypes.UnicodeText
            sqlalchemy.sql.sqltypes.Unicode
                sqlalchemy.sql.sqltypes.NCHAR
                sqlalchemy.sql.sqltypes.NVARCHAR
            sqlalchemy.sql.sqltypes.VARCHAR
        sqlalchemy.sql.sqltypes.Time(sqlalchemy.sql.sqltypes._LookupExpressionAdapter, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.TIME
        sqlalchemy.sql.sqltypes.TupleType
        sqlalchemy.sql.type_api.TypeDecorator(sqlalchemy.sql.type_api.ExternalType, sqlalchemy.sql.base.SchemaEventTarget, sqlalchemy.sql.type_api.TypeEngine)
            sqlalchemy.sql.sqltypes.Interval(sqlalchemy.sql.type_api.Emulated, sqlalchemy.sql.sqltypes._AbstractInterval, sqlalchemy.sql.type_api.TypeDecorator)
            sqlalchemy.sql.sqltypes.PickleType
    
    class AARRRRAAYY(sqlalchemy.sql.base.SchemaEventTarget, Indexable, Concatenable, sqlalchemy.sql.type_api.TypeEngine)
     |  ARRAY(item_type, as_tuple=False, dimensions=None, zero_indexes=False)
     |  
     |  Represent a SQL Array type.
     |  
     |  .. note::  This type serves as the basis for all ARRAY operations.
     |     However, currently **only the PostgreSQL backend has support for SQL
     |     arrays in SQLAlchemy**. It is recommended to use the PostgreSQL-specific
     |     :class:`sqlalchemy.dialects.postgresql.ARRAY` type directly when using
     |     ARRAY types with PostgreSQL, as it provides additional operators
     |     specific to that backend.
     |  
     |  :class:`_types.ARRAY` is part of the Core in support of various SQL
     |  standard functions such as :class:`_functions.array_agg`
     |  which explicitly involve
     |  arrays; however, with the exception of the PostgreSQL backend and possibly
     |  some third-party dialects, no other SQLAlchemy built-in dialect has support
     |  for this type.
     |  
     |  An :class:`_types.ARRAY` type is constructed given the "type"
     |  of element::
     |  
     |      mytable = Table("mytable", metadata,
     |              Column("data", ARRAY(Integer))
     |          )
     |  
     |  The above type represents an N-dimensional array,
     |  meaning a supporting backend such as PostgreSQL will interpret values
     |  with any number of dimensions automatically.   To produce an INSERT
     |  construct that passes in a 1-dimensional array of integers::
     |  
     |      connection.execute(
     |              mytable.insert(),
     |              {"data": [1,2,3]}
     |      )
     |  
     |  The :class:`_types.ARRAY` type can be constructed given a fixed number
     |  of dimensions::
     |  
     |      mytable = Table("mytable", metadata,
     |              Column("data", ARRAY(Integer, dimensions=2))
     |          )
     |  
     |  Sending a number of dimensions is optional, but recommended if the
     |  datatype is to represent arrays of more than one dimension.  This number
     |  is used:
     |  
     |  * When emitting the type declaration itself to the database, e.g.
     |    ``INTEGER[][]``
     |  
     |  * When translating Python values to database values, and vice versa, e.g.
     |    an ARRAY of :class:`.Unicode` objects uses this number to efficiently
     |    access the string values inside of array structures without resorting
     |    to per-row type inspection
     |  
     |  * When used with the Python ``getitem`` accessor, the number of dimensions
     |    serves to define the kind of type that the ``[]`` operator should
     |    return, e.g. for an ARRAY of INTEGER with two dimensions::
     |  
     |        >>> expr = table.c.column[5]  # returns ARRAY(Integer, dimensions=1)
     |        >>> expr = expr[6]  # returns Integer
     |  
     |  For 1-dimensional arrays, an :class:`_types.ARRAY` instance with no
     |  dimension parameter will generally assume single-dimensional behaviors.
     |  
     |  SQL expressions of type :class:`_types.ARRAY` have support for "index" and
     |  "slice" behavior.  The Python ``[]`` operator works normally here, given
     |  integer indexes or slices.  Arrays default to 1-based indexing.
     |  The operator produces binary expression
     |  constructs which will produce the appropriate SQL, both for
     |  SELECT statements::
     |  
     |      select(mytable.c.data[5], mytable.c.data[2:7])
     |  
     |  as well as UPDATE statements when the :meth:`_expression.Update.values`
     |  method
     |  is used::
     |  
     |      mytable.update().values({
     |          mytable.c.data[5]: 7,
     |          mytable.c.data[2:7]: [1, 2, 3]
     |      })
     |  
     |  The :class:`_types.ARRAY` type also provides for the operators
     |  :meth:`.types.ARRAY.Comparator.any` and
     |  :meth:`.types.ARRAY.Comparator.all`. The PostgreSQL-specific version of
     |  :class:`_types.ARRAY` also provides additional operators.
     |  
     |  .. versionadded:: 1.1.0
     |  
     |  .. seealso::
     |  
     |      :class:`sqlalchemy.dialects.postgresql.ARRAY`
     |  
     |  Method resolution order:
     |      ARRAY
     |      sqlalchemy.sql.base.SchemaEventTarget
     |      Indexable
     |      Concatenable
     |      sqlalchemy.sql.type_api.TypeEngine
     |      sqlalchemy.sql.visitors.Traversible
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  ____iinniitt____(self, item_type, as_tuple=False, dimensions=None, zero_indexes=False)
     |      Construct an :class:`_types.ARRAY`.
     |      
     |      E.g.::
     |      
     |        Column('myarray', ARRAY(Integer))
     |      
     |      Arguments are:
     |      
     |      :param item_type: The data type of items of this array. Note that
     |        dimensionality is irrelevant here, so multi-dimensional arrays like
     |        ``INTEGER[][]``, are constructed as ``ARRAY(Integer)``, not as
     |        ``ARRAY(ARRAY(Integer))`` or such.
     |      
     |      :param as_tuple=False: Specify whether return results
     |        should be converted to tuples from lists.  This parameter is
     |        not generally needed as a Python list corresponds well
     |        to a SQL array.
     |      
     |      :param dimensions: if non-None, the ARRAY will assume a fixed
     |       number of dimensions.   This impacts how the array is declared
     |       on the database, how it goes about interpreting Python and
     |       result values, as well as how expression behavior in conjunction
     |       with the "getitem" operator works.  See the description at
     |       :class:`_types.ARRAY` for additional detail.
     |      
     |      :param zero_indexes=False: when True, index values will be converted
     |       between Python zero-based and SQL one-based indexes, e.g.
     |       a value of one will be added to all index values before passing
     |       to the database.
     |  
     |  ccoommppaarree__vvaalluueess(self, x, y)
     |      Compare two values for equality.
     |  
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |  
     |  hhaasshhaabbllee
     |  
     |  ppyytthhoonn__ttyyppee
     |      Return the Python type object expected to be returned
     |      by instances of this type, if known.
     |      
     |      Basically, for those types which enforce a return type,
     |      or are known across the board to do such for all common
     |      DBAPIs (like ``int`` for example), will return that type.
     |      
     |      If a return type is not defined, raises
     |      ``NotImplementedError``.
     |      
     |      Note that any type also accommodates NULL in SQL which
     |      means you can also get back ``None`` from any type
     |      in practice.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  CCoommppaarraattoorr = <class 'sqlalchemy.sql.sqltypes.ARRAY.Comparator'>
     |      Define comparison operations for :class:`_types.ARRAY`.
     |      
     |      More operators are available on the dialect-specific form
     |      of this type.  See :class:`.postgresql.ARRAY.Comparator`.
     |  
     |  
     |  ____vviissiitt__nnaammee____ = 'ARRAY'
     |  
     |  ccoommppaarraattoorr__ffaaccttoorryy = <class 'sqlalchemy.sql.sqltypes.ARRAY.Comparator'...
     |      Define comparison operations for :class:`_types.ARRAY`.
     |      
     |      More operators are available on the dialect-specific form
     |      of this type.  See :class:`.postgresql.ARRAY.Comparator`.
     |  
     |  
     |  zzeerroo__iinnddeexxeess = False
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from sqlalchemy.sql.base.SchemaEventTarget:
     |  
     |  ____ddiicctt____
     |      dictionary for instance variables (if defined)
     |  
     |  ____wweeaakkrreeff____
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from sqlalchemy.sql.base.SchemaEventTarget:
     |  
     |  ddiissppaattcchh = <sqlalchemy.event.base.DDLEventsDispatch object>
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sqlalchemy.sql.type_api.TypeEngine:
     |  
     |  ____rreepprr____(self)
     |      Return repr(self).
     |  
     |  ____ssttrr____(self)
     |      Return str(self).
     |  
     |  aaddaapptt(self, cls, **kw)
     |      Produce an "adapted" form of this type, given an "impl" class
     |      to work with.
     |      
     |      This method is used internally to associate generic
     |      types with "implementation" types that are specific to a particular
     |      dialect.
     |  
     |  aass__ggeenneerriicc(self, allow_nulltype=False)
     |      Return an instance of the generic type corresponding to this type
     |      using heuristic rule. The method may be overridden if this
     |      heuristic rule is not sufficient.
     |      
     |      >>> from sqlalchemy.dialects.mysql import INTEGER
     |      >>> INTEGER(display_width=4).as_generic()
     |      Integer()
     |      
     |      >>> from sqlalchemy.dialects.mysql import NVARCHAR
     |      >>> NVARCHAR(length=100).as_generic()
     |      Unicode(length=100)
     |      
     |      .. versionadded:: 1.4.0b2
     |      
     |      
     |      .. seealso::
     |      
     |          :ref:`metadata_reflection_dbagnostic_types` - describes the
     |          use of :meth:`_types.TypeEngine.as_generic` in conjunction with
     |          the :meth:`_sql.DDLEvents.column_reflect` event, which is its
     |          intended use.
     |  
     |  bbiinndd__eexxpprreessssiioonn(self, bindvalue)
     |      Given a bind value (i.e. a :class:`.BindParameter` instance),
     |      return a SQL expression in its place.
     |      
     |      This is typically a SQL function that wraps the existing bound
     |      parameter within the statement.  It is used for special data types
     |      that require literals being wrapped in some special database function
     |      in order to coerce an application-level value into a database-specific
     |      format.  It is the SQL analogue of the
     |      :meth:`.TypeEngine.bind_processor` method.
     |      
     |      This method is called during the **SQL compilation** phase of a
     |      statement, when rendering a SQL string. It is **not** called
     |      against specific values.
     |      
     |      Note that this method, when implemented, should always return
     |      the exact same structure, without any conditional logic, as it
     |      may be used in an executemany() call against an arbitrary number
     |      of bound parameter sets.
     |      
     |      .. note::
     |      
     |          This method is only called relative to a **dialect specific type
     |          object**, which is often **private to a dialect in use** and is not
     |          the same type object as the public facing one, which means it's not
     |          feasible to subclass a :class:`.types.TypeEngine` class in order to
     |          provide an alternate :meth:`_types.TypeEngine.bind_expression`
     |          method, unless subclassing the :class:`_types.UserDefinedType`
     |          class explicitly.
     |      
     |          To provide alternate behavior for
     |          :meth:`_types.TypeEngine.bind_expression`, implement a
     |          :class:`_types.TypeDecorator` class and provide an implementation
     |          of :meth:`_types.TypeDecorator.bind_expression`.
     |      
     |          .. seealso::
     |      
     |              :ref:`types_typedecorator`
     |      
     |      .. seealso::
     |      
     |          :ref:`types_sql_value_processing`
     |  
     |  bbiinndd__pprroocceessssoorr(self, dialect)
     |      Return a conversion function for processing bind values.
     |      
     |      Returns a callable which will receive a bind parameter value
     |      as the sole positional argument and will return a value to
     |      send to the DB-API.
     |      
     |      If processing is not necessary, the method should return ``None``.
     |      
     |      .. note::
     |      
     |          This method is only called relative to a **dialect specific type
     |          object**, which is often **private to a dialect in use** and is not
     |          the same type object as the public facing one, which means it's not
     |          feasible to subclass a :class:`.types.TypeEngine` class in order to
     |          provide an alternate :meth:`_types.TypeEngine.bind_processor`
     |          method, unless subclassing the :class:`_types.UserDefinedType`
     |          class explicitly.
     |      
     |          To provide alternate behavior for
     |          :meth:`_types.TypeEngine.bind_processor`, implement a
     |          :class:`_types.TypeDecorator` class and provide an implementation
     |          of :meth:`_types.TypeDecorator.process_bind_param`.
     |      
     |          .. seealso::
     |      
     |              :ref:`types_typedecorator`
     |      
     |      
     |      :param dialect: Dialect instance in use.
     |  
     |  ccooeerrccee__ccoommppaarreedd__vvaalluuee(self, op, value)
     |      Suggest a type for a 'coerced' Python value in an expression.
     |      
     |      Given an operator and value, gives the type a chance
     |      to return a type which the value should be coerced into.
     |      
     |      The default behavior here is conservative; if the right-hand
     |      side is already coerced into a SQL type based on its
     |      Python type, it is usually left alone.
     |      
     |      End-user functionality extension here should generally be via
     |      :class:`.TypeDecorator`, which provides more liberal behavior in that
     |      it defaults to coercing the other side of the expression into this
     |      type, thus applying special Python conversions above and beyond those
     |      needed by the DBAPI to both ides. It also provides the public method
     |      :meth:`.TypeDecorator.coerce_compared_value` which is intended for
     |      end-user customization of this behavior.
     |  
     |  ccoolluummnn__eexxpprreessssiioonn(self, colexpr)
     |      Given a SELECT column expression, return a wrapping SQL expression.
     |      
     |      This is typically a SQL function that wraps a column expression
     |      as rendered in the columns clause of a SELECT statement.
     |      It is used for special data types that require
     |      columns to be wrapped in some special database function in order
     |      to coerce the value before being sent back to the application.
     |      It is the SQL analogue of the :meth:`.TypeEngine.result_processor`
     |      method.
     |      
     |      This method is called during the **SQL compilation** phase of a
     |      statement, when rendering a SQL string. It is **not** called
     |      against specific values.
     |      
     |      .. note::
     |      
     |          This method is only called relative to a **dialect specific type
     |          object**, which is often **private to a dialect in use** and is not
     |          the same type object as the public facing one, which means it's not
     |          feasible to subclass a :class:`.types.TypeEngine` class in order to
     |          provide an alternate :meth:`_types.TypeEngine.column_expression`
     |          method, unless subclassing the :class:`_types.UserDefinedType`
     |          class explicitly.
     |      
     |          To provide alternate behavior for
     |          :meth:`_types.TypeEngine.column_expression`, implement a
     |          :class:`_types.TypeDecorator` class and provide an implementation
     |          of :meth:`_types.TypeDecorator.column_expression`.
     |      
     |          .. seealso::
     |      
     |              :ref:`types_typedecorator`
     |      
     |      
     |      .. seealso::
     |      
     |          :ref:`types_sql_value_processing`
     |  
     |  ccoommppaarree__aaggaaiinnsstt__bbaacckkeenndd(self, dialect, conn_type)
     |      Compare this type against the given backend type.
     |      
     |      This function is currently not implemented for SQLAlchemy
     |      types, and for all built in types will return ``None``.  However,
     |      it can be implemented by a user-defined type
     |      where it can be consumed by schema comparison tools such as
     |      Alembic autogenerate.
     |      
     |      A future release of SQLAlchemy will potentially implement this method
     |      for builtin types as well.
     |      
     |      The function should return True if this type is equivalent to the
     |      given type; the type is typically reflected from the database
     |      so should be database specific.  The dialect in use is also
     |      passed.   It can also return False to assert that the type is
     |      not equivalent.
     |      
     |      :param dialect: a :class:`.Dialect` that is involved in the comparison.
     |      
     |      :param conn_type: the type object reflected from the backend.
     |      
     |      .. versionadded:: 1.0.3
     |  
     |  ccoommppiillee(self, dialect=None)
     |      Produce a string-compiled form of this :class:`.TypeEngine`.
     |      
     |      When called with no arguments, uses a "default" dialect
     |      to produce a string result.
     |      
     |      :param dialect: a :class:`.Dialect` instance.
     |  
     |  ccooppyy(self, **kw)
     |  
     |  ccooppyy__vvaalluuee(self, value)
     |  
     |  ddiiaalleecctt__iimmppll(self, dialect)
     |      Return a dialect-specific implementation for this
     |      :class:`.TypeEngine`.
     |  
     |  eevvaalluuaatteess__nnoonnee(self)
     |      Return a copy of this type which has the
     |      :attr:`.should_evaluate_none` flag set to True.
     |      
     |      E.g.::
     |      
     |              Table(
     |                  'some_table', metadata,
     |                  Column(
     |                      String(50).evaluates_none(),
     |                      nullable=True,
     |                      server_default='no value')
     |              )
     |      
     |      The ORM uses this flag to indicate that a positive value of ``None``
     |      is passed to the column in an INSERT statement, rather than omitting
     |      the column from the INSERT statement which has the effect of firing
     |      off column-level defaults.   It also allows for types which have
     |      special behavior associated with the Python None value to indicate
     |      that the value doesn't necessarily translate into SQL NULL; a
     |      prime example of this is a JSON type which may wish to persist the
     |      JSON value ``'null'``.
     |      
     |      In all cases, the actual NULL SQL value can be always be
     |      persisted in any column by using
     |      the :obj:`_expression.null` SQL construct in an INSERT statement
     |      or associated with an ORM-mapped attribute.
     |      
     |      .. note::
     |      
     |          The "evaluates none" flag does **not** apply to a value
     |          of ``None`` passed to :paramref:`_schema.Column.default` or
     |          :paramref:`_schema.Column.server_default`; in these cases,
     |          ``None``
     |          still means "no default".
     |      
     |      .. versionadded:: 1.1
     |      
     |      .. seealso::
     |      
     |          :ref:`session_forcing_null` - in the ORM documentation
     |      
     |          :paramref:`.postgresql.JSON.none_as_null` - PostgreSQL JSON
     |          interaction with this flag.
     |      
     |          :attr:`.TypeEngine.should_evaluate_none` - class-level flag
     |  
     |  ggeett__ddbbaappii__ttyyppee(self, dbapi)
     |      Return the corresponding type object from the underlying DB-API, if
     |      any.
     |      
     |      This can be useful for calling ``setinputsizes()``, for example.
     |  
     |  lliitteerraall__pprroocceessssoorr(self, dialect)
     |      Return a conversion function for processing literal values that are
     |      to be rendered directly without using binds.
     |      
     |      This function is used when the compiler makes use of the
     |      "literal_binds" flag, typically used in DDL generation as well
     |      as in certain scenarios where backends don't accept bound parameters.
     |      
     |      Returns a callable which will receive a literal Python value
     |      as the sole positional argument and will return a string representation
     |      to be rendered in a SQL statement.
     |      
     |      .. note::
     |      
     |          This method is only called relative to a **dialect specific type
     |          object**, which is often **private to a dialect in use** and is not
     |          the same type object as the public facing one, which means it's not
     |          feasible to subclass a :class:`.types.TypeEngine` class in order to
     |          provide an alternate :meth:`_types.TypeEngine.literal_processor`
     |          method, unless subclassing the :class:`_types.UserDefinedType`
     |          class explicitly.
     |      
     |          To provide alternate behavior for
     |          :meth:`_types.TypeEngine.literal_processor`, implement a
     |          :class:`_types.TypeDecorator` class and provide an implementation
     |          of :meth:`_types.TypeDecorator.process_literal_param`.
     |      
     |          .. seealso::
     |      
     |              :ref:`types_typedecorator`
     |  
     |  rreessuulltt__pprroocceessssoorr(self, dialect, coltype)
     |      Return a conversion function for processing result row values.
     |      
     |      Returns a callable which will receive a result row column
     |      value as the sole positional argument and will return a value
     |      to return to the user.
     |      
     |      If processing is not necessary, the method should return ``None``.
     |      
     |      .. note::
     |      
     |          This method is only called relative to a **dialect specific type
     |          object**, which is often **private to a dialect in use** and is not
     |          the same type object as the public facing one, which means it's not
     |          feasible to subclass a :class:`.types.TypeEngine` class in order to
     |          provide an alternate :meth:`_types.TypeEngine.result_processor`
     |          method, unless subclassing the :class:`_types.UserDefinedType`
     |          class explicitly.
     |      
     |          To provide alternate behavior for
     |          :meth:`_types.TypeEngine.result_processor`, implement a
     |          :class:`_types.TypeDecorator` class and provide an implementation
     |          of :meth:`_types.TypeDecorator.process_result_value`.
     |      
     |          .. seealso::
     |      
     |              :ref:`types_typedecorator`
     |      
     |      :param dialect: Dialect instance in use.
     |      
     |      :param coltype: DBAPI coltype argument received in cursor.description.
     |  
     |  wwiitthh__vvaarriiaanntt(self, type_, dialect_name)
     |      Produce a new type object that will utilize the given
     |      type when applied to the dialect of the given name.
     |      
     |      e.g.::
     |      
     |          from sqlalchemy.types import String
     |          from sqlalchemy.dialects import mysql
     |      
     |          s = String()
     |      
     |          s = s.with_variant(mysql.VARCHAR(collation='foo'), 'mysql')
     |      
     |      The construction of :meth:`.TypeEngine.with_variant` is always
     |      from the "fallback" type to that which is dialect specific.
     |      The returned type is an instance of :class:`.Variant`, which
     |      itself provides a :meth:`.Variant.with_variant`
     |      that can be called repeatedly.
     |      
     |      :param type\_: a :class:`.TypeEngine` that will be selected
     |       as a variant from the originating type, when a dialect
     |       of the given name is in use.
     |      :param dialect_name: base name of the dialect which uses
     |       this type. (i.e. ``'postgresql'``, ``'mysql'``, etc.)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from sqlalchemy.sql.type_api.TypeEngine:
     |  
     |  sshhoouulldd__eevvaalluuaattee__nnoonnee = False
     |  
     |  ssoorrtt__kkeeyy__ffuunnccttiioonn = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from sqlalchemy.sql.visitors.Traversible:
     |  
     |  ggeett__cchhiillddrreenn(self, omit_attrs=(), **kw)
     |      Return immediate child :class:`.visitors.Traversible`
     |      elements of this :class:`.visitors.Traversible`.
     |      
     |      This is used for visit traversal.
     |      
     |      \**kw may contain flags that change the collection that is
     |      returned, for example to return a subset of items in order to
     |      cut down on larger traversals, or to return child items from a
     |      different context (such as schema-level collections instead of
     |      clause-level).
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from sqlalchemy.sql.visitors.Traversible:
     |  
     |  ____ccllaassss__ggeettiitteemm____(key) from sqlalchemy.sql.visitors.TraversibleType
    
    class BBIIGGIINNTT(BigInteger)
     |  The SQL BIGINT type.
     |  
     |  Method resolution order:
     |      BIGINT
     |      BigInteger
     |      Integer
     |      _LookupExpressionAdapter
     |      sqlalchemy.sql.type_api.TypeEngine
     |      sqlalchemy.sql.visitors.Traversible
     |      builtins.object
     |  
     |  Data and other attributes defined here:
     |  
     |  ____vviissiitt__nnaammee____ = 'BIGINT'
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from Integer:
     |  
     |  ggeett__ddbbaappii__ttyyppee(self, dbapi)
     |      Return the corresponding type object from the underlying DB-API, if
     |      any.
     |      
     |      This can be useful for calling ``setinputsizes()``, for example.
     |  
     |  lliitteerraall__pprroocceessssoorr(self, dialect)
     |      Return a conversion function for processing literal values that are
     |      to be rendered directly without using binds.
     |      
     |      This function is used when the compiler makes use of the
     |      "literal_binds" flag, typically used in DDL generation as well
     |      as in certain scenarios where backends don't accept bound parameters.
     |      
     |      Returns a callable which will receive a literal Python value
     |      as the sole positional argument and will return a string representation
     |      to be rendered in a SQL statement.
     |      
     |      .. note::
     |      
     |       